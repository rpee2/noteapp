{% extends "base.html" %} {% block title %}Note{% endblock %} {% block
  insert_head_here %}
  
  <link href="https://cdn.quilljs.com/1.3.6/quill.bubble.css" rel="stylesheet">

  <style>
    .workspace {
      height: 100vh;
      padding: 2em 12em;
    }
  
    .workspace form {
      height: 100%;
      display: grid;
      grid-auto-rows: min-content;
      gap: 1em;
      font-size: 1.45em;
    }
  
    /* this is how i achieve the effect of label and title in one nice border  */
    .input-group {
      display: grid;
      width: 100%;
      grid-template-columns: auto 1fr;
    }
  
    .input-group label {
      height: 100%;
      border: 1px solid hsl(210, 13%, 85%);
      border-right: none;
      border-top-left-radius: 5px;
      border-bottom-left-radius: 5px;
      outline: none;
      padding: 0.6em;
      background-color: hsla(
        var(--primary-h),
        var(--primary-s),
        var(--primary-l),
        0.3
      );
      color: var(--text);
    }
  
    :root[data-theme="dark"] .input-group label {
      border: 1px solid hsl(210, 13%, 20%);
      border-right: none;
      background-color: hsla(
        var(--primary-h),
        var(--primary-s),
        var(--primary-l),
        0.7
      );
    }
  
    .input-group input {
      width: 100%;
      padding: 1em;
      border: 1px solid hsl(210, 13%, 85%);
      border-left: none;
      border-top-right-radius: 5px;
      border-bottom-right-radius: 5px;
      color: var(--text);
    }
  
    :root[data-theme="dark"] .input-group input {
      border: 1px solid hsl(210, 13%, 20%);
      border-left: none;
      background-color: hsla(0, 0%, 10%, 0.8);
    }
  
    .input-group input:focus {
      outline: 2px solid
        hsla(var(--primary-h), var(--primary-s), var(--primary-l), 0.3);
    }
  
    .input-dropdown {
      position: relative;
      width: 100%;
    }
  
    .autocomplete-items {
      position: absolute;
      width: inherit;
      border: 1px solid #d4d4d4;
      border-top: none;
      max-height: 300px;
      overflow-y: auto;
      z-index: 2;
      background-color: hsla(0, 0%, 100%);
    }
  
    :root[data-theme="dark"] .autocomplete-items {
      background-color: hsla(0, 0%, 0%);
    }
  
    /* .autocomplete-item is generated by js */
    .autocomplete-item {
      padding: 8px;
      color: var(--text);
      cursor: pointer;
    }
  
    .autocomplete-item:hover {
      background-color: hsla(322, 100%, 50%, 0.3);
    }
  
    :root[data-theme="dark"] .autocomplete-item:hover {
      background-color: hsla(322, 100%, 50%, 0.7);
    }
  
    .autocomplete-item-disabled {
      padding: 8px;
      color: hsl(0, 0%, 80%);
    }
  
    :root[data-theme="dark"] .autocomplete-item-disabled {
      padding: 8px;
      color: hsl(0, 0%, 20%);
    }
  
    .autocomplete-item-disabled:active {
      pointer-events: none;
    }
  
    /* .selected-tag is generated by js  */
    .selected-tag {
      caret-color: transparent;
      display: inline-flex;
      align-items: center;
      border-radius: 20px;
      margin: 4px;
      padding: 6px 12px;
      background-color: var(--secondary);
      color: var(--text);
    }
  
    .selected-tag span {
      margin-right: 8px;
    }
  
    .selected-tag .close-icon {
      cursor: pointer;
      color: var(--text);
      opacity: 0.8;
    }
  
    .input-text-group {
      width: 100%;
      display: flex;
      margin-top: 1em;
      border: 1px solid hsl(210, 13%, 85%);
      border-radius: 4px;
    }
  
    :root[data-theme="dark"] .input-text-group {
      border: 1px solid hsl(210, 13%, 25%);
    }
  
    .input-text-group .editor:focus {
      outline: none;
      border: 2px solid
        hsla(var(--primary-h), var(--primary-s), var(--primary-l), 0.3);
    }
  
    .editor {
      flex: 1 1;
      border: 0; /* remove the default border  */
      border-radius: inherit;
      padding: 0.5em;
      resize: none;
      background-color: white;
      color: var(--text);
    }
    
    :root[data-theme="dark"] .editor {
      background-color: hsl(0, 0%, 8%);
    }
    
    #editor {
      font-size: 1.6rem;
    }

    .ql-editor {
      tab-size: 4;
      -moz-tab-size: 4;
      -o-tab-size: 4;
    }

    :root[data-theme="dark"] #editor code {
      background-color: hsl(0, 0%, 27%);
    }

    :root[data-theme="dark"] #editor a {
      color: hsl(320, 93%, 69%);
    }

    :root[data-theme="dark"] #editor a::before {
      background-color: hsl(0, 0%, 73%);
      color: black;
    }
  
    .input-group .save-button {
      /* all: unset; https://css-tricks.com/overriding-default-button-styles/ */
      border: none;
      border-radius: 5px;
      padding: 0.5em;
      outline: inherit;
      background-color: hsla(322, 100%, 60%, 0.3);
      color: var(--text);
      font: inherit;
      cursor: pointer;
    }
  
    :root[data-theme="dark"] .input-group .save-button {
      background-color: hsla(322, 100%, 60%, 0.7);
    }
  
    .input-group .save-button:focus {
      outline: 2px solid
        hsla(var(--primary-h), var(--primary-s), var(--primary-l), 0.3);
    }
  
    .input-group .save-button:focus,
    .input-group .save-button:hover {
      background-color: hsla(322, 100%, 60%, 0.35);
    }
  
    :root[data-theme="dark"] .input-group .save-button:focus,
    :root[data-theme="dark"] .input-group .save-button:hover {
      background-color: hsla(322, 100%, 50%, 0.65);
    }
  </style>

  {% endblock %} {% block content %}
  <div class="workspace">
    <form method="POST" id="js-note-form">

      {{ form.hidden_tag() }}
      <div class="input-group">
        {{ form.tag_search.label() }}
        <!-- <label for="js-autocomplete-input">Tags</label> -->
      
        <div class="input-dropdown">
            {{ form.tag_search(
              type="text",
              id="js-autocomplete-input",
              placeholder="search for tags"
            )}}
            <!-- <input
              type="text"
              id="js-autocomplete-input"
              placeholder="search for tags"
            />  -->
  
          <div class="autocomplete-items" id="js-autocomplete-dropdown"></div>
        </div>
      </div>
  
      <div class="selected-tags" id="js-selected-tags-display">
      <!-- string of tags submitted by form  -->
      {{ form.note_tags(
        type="hidden",
        id="js-selected-tags"
        )}}
      <!-- <input type="hidden" name="note-tags" id="js-selected-tags" /> -->
    </div>
  
    <div class="input-group">
      {{ form.note_title.label }} 
      {{ form.note_title(
        type="text",
        id="label-title",
        value=current_note.title ) }}
      <!-- <label for="label-title">Title</label>
      <input
        type="text"
        id="label-title"
        name="note-title"
        value="{{ note_title }}"
      /> -->
    </div>
  
      <div class="input-text-group">
        <div class="editor" id="editor" name="note_body"></div>
      </div>
  
      <div class="input-group">
        {{ form.save(class="save-button", type="submit") }} 
        <!-- <button type="submit" onclick="checkSaved()">Save</button> -->
      </div>
    </form>
  </div>
{% endblock %} {% block insert_script_here %}

<script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>

<script>
  var toolbarOptions = [
    ['bold', 'italic', 'underline', 'strike', 'link', 'code', 'blockquote'],  
    [{ 'background': ['#3e30a14d', '#3e30a180'] }],  
    [{ 'list': 'ordered'}, { 'list': 'bullet' }],
    [{ 'header': 1 }, { 'header': 2 }], 
    [{ 'indent': '-1'}, { 'indent': '+1' },{ 'align': [] }],       
    [{ 'font': [] }],
    ['clean'] // remove formatting button
  ];

  var quill = new Quill('#editor', {
    modules: {
      toolbar: toolbarOptions
    },
    theme: 'bubble'
  });
  
  var note_form = document.getElementById("js-note-form");
  
  var delta = {{ current_note.body_delta|tojson }};
  if (delta) {
    quill.setContents(JSON.parse(delta));
  }
  
  // https://github.com/quilljs/quill/issues/2276
  note_form.addEventListener("submit", function () {
    var note_body_delta = note_form.querySelector("input[name=note_body_delta]");
    var note_body_html = note_form.querySelector("input[name=note_body_html]");
    var note_body_text = note_form.querySelector("input[name=note_body_text]");

    note_body_delta.value = JSON.stringify(quill.getContents());
    note_body_html.value = quill.root.innerHTML;
    note_body_text.value = quill.getText();
    
    return true;
  });
</script>

<script>
    const user_tags = {{ js_user_tags|tojson }};
    const initial_tags = {{ js_note_tags|tojson }};
    const input = document.getElementById("js-autocomplete-input");
    const suggestionsContainer = document.getElementById("js-autocomplete-dropdown");
    const selectedTagsContainer = document.getElementById("js-selected-tags-display");

    // const textarea = document.querySelector('textarea');
    // let unsavedChanges = false;


    // 0a - load the tags on page load (the title are text are handled by jinja)
    window.addEventListener("load", (event) => {
      initial_tags.forEach((tag) => {
        addSelectedTag(tag)
      });
    });

    window.addEventListener("load", function () {
      suggestionsContainer.hidden = true;
    });


  // 0b - prompt user if there are unsaved changes in the textarea
    // textarea.addEventListener("input", function (event) {
    //   unsavedChanges = true;
    // });

    // function checkSaved() {
    //   unsavedChanges = false; // because you are going to save it next
    // }

    // window.addEventListener("beforeunload", function (event) {
    //     if (unsavedChanges) {
    //       event.preventDefault();
    //   }
    // });


    // 1- show all tags when user clicks on the search box
    input.addEventListener("click", function () {
      // console.log("clicked")
      suggestionsContainer.innerHTML = "";
      orderDropdown(user_tags);
    });


    // 2- show filtered tags when user types in the search box
    input.addEventListener("input", function () {
      // console.log("typing")
      // everytime you type in a letter, reset the whole search
      suggestionsContainer.innerHTML = "";
      // change the tag name to lowercase and compare with the input
      const inputValue = input.value.toLowerCase();
      const filteredTags = user_tags.filter((tag) =>
        tag.name.toLowerCase().includes(inputValue)
      );
      // console.log(filteredTags);
      filteredTags.forEach((filteredTag) => {
        createDropdownHTML(filteredTag)
      });

    });


    // there's a lot of const that get passed around for this function, is this the best way to do it?
    // https://code.tutsplus.com/javascript-map-vs-foreach-when-to-use-each-one--cms-38365t
    function orderDropdown(taglist) {
      const level1tags = taglist.filter((tag)=>tag.level==1);
      const level2tags = taglist
        .filter((tag)=>tag.level==2)
        .sort((a,b) => a.order - b.order);

        // create the level 1 tags
        level1tags.forEach((parentTag) => {
        createDropdownHTML(parentTag)
        // create the level 2 tags below the relevant level 1 tag
        const parentID = parentTag.id
        level2tags.forEach((childTag) => {
          if (childTag.parent_tag == parentID) {
            createDropdownHTML(childTag)
          }
        });
      });
    };

    // for each tag, create the HTML to display tag on the dropdown
    function createDropdownHTML (tag) {
      const suggestionItem = document.createElement("div");
      if (selectedTagsContainer.innerHTML.includes(tag.name)) { // check to see if the tag is already included in the selectedTagsContainer, if it is, then disable it in the suggestionsContainer (using pointer-events: none and cursor: not allowed) - without innerHTML you get an error
        suggestionItem.className = "autocomplete-item-disabled"; // i have to create a custom class because the disabled attribute only applies to forms
      } else {
        suggestionItem.className = "autocomplete-item";
      }
      if (tag.parent_tag == null) {
        suggestionItem.textContent = tag.name;
        // suggestionItem.innerHTML = "<b>" + tag.name + "</b>"; // bold
      } else {
        suggestionItem.innerHTML = "&emsp;" + tag.name;
      }
      suggestionsContainer.appendChild(suggestionItem);

      suggestionItem.addEventListener("click", function () {
          addSelectedTag(tag);
          updateInput(); //update hidden input field
          input.value = "";
          suggestionsContainer.innerHTML = "";
        });
    };


    // add the HTML for current tags when user first loads AND for the clicked tag when user clicks
    function addSelectedTag(tag) {
      const selectedTag = document.createElement("div");
      selectedTag.className = "selected-tag";
      selectedTag.id = tag.id; // we pass the tag.id to query the tag in POST
      const tagText = document.createElement("span");
      tagText.textContent = tag.name; // basically <span>anything inside here is the textContext</span> https://teamtreehouse.com/community/value-vs-textcontent
      const closeIcon = document.createElement("span");
      closeIcon.className = "close-icon";
      closeIcon.innerHTML = "✕"; // https://stackoverflow.com/questions/49197622/how-to-use-an-entity-with-textcontent

      selectedTag.appendChild(tagText);
      selectedTag.appendChild(closeIcon);
      selectedTagsContainer.appendChild(selectedTag);
      updateInput();


      // function to remove the tag when the x is pressed
      closeIcon.onclick = function () {
        selectedTagsContainer.removeChild(selectedTag);
        updateInput(); // update the deleted tag in the form
      };
    }


    // update the hidden input by reviewing the current state of the selectedTagsContainer
    // since this function is only used by createDropdown, is it better to nest the function?
    function updateInput() {
      const selectedTagsInput = document.getElementById("js-selected-tags");
      const selectedTags = [...selectedTagsContainer.getElementsByClassName("selected-tag")].map(x => x.id); // there are typically one or more tags which have been selected, so we turn the "selected-tag" elements in the selected tags container into an array. Then we map each element to its id
      selectedTagsInput.value = selectedTags.join(",");
      // console.log(selectedTagsInput.value);
    }


    // if user clicks outside the dropdown or the input, close the dropdown
    // alternative 1
    document.addEventListener("click", function (event) {
      if (
        !(
          suggestionsContainer.contains(event.target) ||
          input.contains(event.target)
        )
      ) {
        suggestionsContainer.hidden = true;
      } else suggestionsContainer.hidden = false;
    });

    // alternative 2
    // suggestionsContainer.addEventListener("focus", function () {
    //   suggestionsContainer.hidden = false;
    // });
    // suggestionsContainer.addEventListener("blur", function () {
    //   suggestionsContainer.hidden = true;
    // });
</script>
{% endblock %}
  