{% extends "base.html" %} {% block title %}Note{% endblock %} {% block
insert_head_here %}
<style>
  .workspace {
    height: 100vh;
    padding: 2em 12em;
  }

  /* let the text area take up the remaining space */
  .workspace form {
    height: 100%;
    display: grid;
    grid-template-rows: min-content min-content min-content 1fr min-content;
    gap: 1em;
    font-size: 1.45em;
  }

  /* this is how i achieve the effect of label and title in one nice border  */
  .input-group {
    display: grid;
    width: 100%;
    grid-template-columns: auto 1fr;
  }

  .input-group label {
    height: 100%;
    border: 1px solid hsl(210, 13%, 85%);
    border-right: none;
    border-top-left-radius: 5px;
    border-bottom-left-radius: 5px;
    outline: none;
    padding: 0.6em;
    background-color: hsla(
      var(--primary-h),
      var(--primary-s),
      var(--primary-l),
      0.3
    );
    color: var(--text);
  }

  :root[data-theme="dark"] .input-group label {
    border: 1px solid hsl(210, 13%, 20%);
    border-right: none;
    background-color: hsla(
      var(--primary-h),
      var(--primary-s),
      var(--primary-l),
      0.7
    );
  }

  .input-group input {
    width: 100%;
    padding: 1em;
    border: 1px solid hsl(210, 13%, 85%);
    border-left: none;
    border-top-right-radius: 5px;
    border-bottom-right-radius: 5px;
    color: var(--text);
  }

  :root[data-theme="dark"] .input-group input {
    border: 1px solid hsl(210, 13%, 20%);
    border-left: none;
    background-color: hsla(0, 0%, 10%, 0.8);
  }

  .input-group input:focus {
    outline: 2px solid
      hsla(var(--primary-h), var(--primary-s), var(--primary-l), 0.3);
  }

  .input-dropdown {
    position: relative;
    width: 100%;
  }

  .autocomplete-items {
    position: absolute;
    width: inherit;
    border: 1px solid #d4d4d4;
    border-top: none;
    max-height: 300px;
    overflow-y: auto;
    z-index: 2;
    background-color: hsla(0, 0%, 100%);
  }

  :root[data-theme="dark"] .autocomplete-items {
    background-color: hsla(0, 0%, 0%);
  }

  /* .autocomplete-item is generated by js */
  .autocomplete-item {
    padding: 8px;
    color: var(--text);
    cursor: pointer;
  }

  .autocomplete-item:hover {
    background-color: hsla(322, 100%, 50%, 0.3);
  }

  :root[data-theme="dark"] .autocomplete-item:hover {
    background-color: hsla(322, 100%, 50%, 0.7);
  }

  .autocomplete-item-disabled {
    padding: 8px;
    color: hsl(0, 0%, 80%);
  }

  :root[data-theme="dark"] .autocomplete-item-disabled {
    padding: 8px;
    color: hsl(0, 0%, 20%);
  }

  .autocomplete-item-disabled:active {
    pointer-events: none;
  }

  /* .selected-tag is generated by js  */
  .selected-tag {
    caret-color: transparent;
    display: inline-flex;
    align-items: center;
    border-radius: 20px;
    margin: 4px;
    padding: 6px 12px;
    background-color: var(--secondary);
    color: var(--text);
  }

  .selected-tag span {
    margin-right: 8px;
  }

  .selected-tag .close-icon {
    cursor: pointer;
    color: var(--text);
    opacity: 0.8;
  }

  .input-text-group {
    width: 100%;
    display: flex;
    margin-top: 1em;
    overflow: hidden;
    border: 1px solid hsl(210, 13%, 85%);
    border-radius: 5px;
  }

  :root[data-theme="dark"] .input-text-group {
    border: 1px solid hsl(210, 13%, 25%);
  }

  .input-text-group textarea:focus {
    outline: none;
    border: 2px solid
      hsla(var(--primary-h), var(--primary-s), var(--primary-l), 0.3);
  }

  .text-area {
    overflow-y: auto;
    overflow-x: hidden;
    flex: 1 1;
    border: 0; /* remove the default border  */
    border-radius: inherit;
    padding: 0.5em;
    resize: none;
    color: var(--text);
    font-family: "Poppins";
    scrollbar-color: hsla(322, 100%, 50%, 0.5)
      hsla(var(--primary-h), var(--primary-s), var(--primary-l), 0.3);
    scrollbar-width: thin;
  }

  :root[data-theme="dark"] .text-area {
    background-color: hsla(0, 0%, 10%, 0.8);
  }

  .input-group button {
    /* all: unset; https://css-tricks.com/overriding-default-button-styles/ */
    border: none;
    border-radius: 5px;
    padding: 0.5em;
    outline: inherit;
    background-color: hsla(322, 100%, 60%, 0.3);
    color: var(--text);
    font: inherit;
    cursor: pointer;
  }

  :root[data-theme="dark"] .input-group button {
    background-color: hsla(322, 100%, 60%, 0.7);
  }

  .input-group button:focus {
    outline: 2px solid
      hsla(var(--primary-h), var(--primary-s), var(--primary-l), 0.3);
  }

  .input-group button:focus,
  .input-group button:hover {
    background-color: hsla(322, 100%, 60%, 0.35);
  }

  :root[data-theme="dark"] .input-group button:focus,
  :root[data-theme="dark"] .input-group button:hover {
    background-color: hsla(322, 100%, 50%, 0.65);
  }
</style>
{% endblock %} {% block content %}
<div class="workspace">
  <form method="POST">
    <div class="input-group">
      <label for="js-autocomplete-input">Tags</label>
      <div class="input-dropdown">
        <input
          type="text"
          id="js-autocomplete-input"
          placeholder="search for tags"
        />
        <div class="autocomplete-items" id="js-autocomplete-dropdown"></div>
      </div>
    </div>

    <div class="selected-tags" id="js-selected-tags-display">
      <!-- hidden input  -->
      <input type="hidden" name="note-tags" id="js-selected-tags" />
    </div>

    <div class="input-group">
      <label for="label-title">Title</label>
      <input
        type="text"
        id="label-title"
        name="note-title"
        value="{{ note_title }}"
      />
    </div>

    <div class="input-text-group">
      <textarea class="text-area" name="note-body">{{ note_body }}</textarea>
    </div>

    <div class="input-group">
      <button type="submit" onclick="formButton()">Save</button>
    </div>
  </form>
</div>
{% endblock %} {% block insert_script_here %}
<script>
    const user_tags = {{ js_user_tags|tojson }};
    const initial_tags = {{ js_note_tags|tojson }};
    const input = document.getElementById("js-autocomplete-input");
    const suggestionsContainer = document.getElementById("js-autocomplete-dropdown");
    const selectedTagsContainer = document.getElementById("js-selected-tags-display");

    const textarea = document.querySelector('textarea');
    let unsavedChanges = false;


    // 0a - load the tags on page load (the title are text are handled by jinja)
    window.addEventListener("load", (event) => {
      initial_tags.forEach((tag) => {
        addSelectedTag(tag)
      });
    });

    window.onload = function () {
      suggestionsContainer.hidden = true;
    };


  // 0b - prompt user if there are unsaved changes in the textarea
    textarea.addEventListener("input", function (event) {
      unsavedChanges = true;
    });

    function formButton() {
      unsavedChanges = false; // because you are going to save it next
    }

    window.addEventListener("beforeunload", function (event) {
        if (unsavedChanges) {
          event.preventDefault();
      }
    });


    // 1- show all tags when user clicks on the search box
    input.addEventListener("click", function () {
      suggestionsContainer.innerHTML = "";
      orderDropdown(user_tags);
    });


    // 2- show filtered tags when user types in the search box
    input.addEventListener("input", function () {
      // everytime you type in a letter, reset the whole search
      suggestionsContainer.innerHTML = "";
      // change the tag name to lowercase and compare with the input
      const inputValue = input.value.toLowerCase();
      const filteredTags = user_tags.filter((tag) =>
        tag.name.toLowerCase().includes(inputValue)
      );
      // console.log(filteredTags);
      filteredTags.forEach((filteredTag) => {
        createDropdownHTML(filteredTag)
      });

    });


    // there's a lot of const that get passed around for this function, is this the best way to do it?
    // https://code.tutsplus.com/javascript-map-vs-foreach-when-to-use-each-one--cms-38365t
    function orderDropdown(taglist) {
      const level1tags = taglist.filter((tag)=>tag.level==1);
      const level2tags = taglist
        .filter((tag)=>tag.level==2)
        .sort((a,b) => a.order - b.order);

        // create the level 1 tags
        level1tags.forEach((parentTag) => {
        createDropdownHTML(parentTag)
        // create the level 2 tags below the relevant level 1 tag
        const parentID = parentTag.id
        level2tags.forEach((childTag) => {
          if (childTag.parent_tag == parentID) {
            createDropdownHTML(childTag)
          }
        });
      });
    };

    // for each tag, create the HTML to display tag on the dropdown
    function createDropdownHTML (tag) {
      const suggestionItem = document.createElement("div");
      if (selectedTagsContainer.innerHTML.includes(tag.name)) { // check to see if the tag is already included in the selectedTagsContainer, if it is, then disable it in the suggestionsContainer (using pointer-events: none and cursor: not allowed) - without innerHTML you get an error
        suggestionItem.className = "autocomplete-item-disabled"; // i have to create a custom class because the disabled attribute only applies to forms
      } else {
        suggestionItem.className = "autocomplete-item";
      }
      if (tag.parent_tag == null) {
        suggestionItem.textContent = tag.name;
        // suggestionItem.innerHTML = "<b>" + tag.name + "</b>"; // bold
      } else {
        suggestionItem.innerHTML = "&emsp;" + tag.name;
      }
      suggestionsContainer.appendChild(suggestionItem);

      suggestionItem.addEventListener("click", function () {
          addSelectedTag(tag);
          updateForm(); //update hidden input field
          input.value = "";
          suggestionsContainer.innerHTML = "";
        });
    };


    // add the HTML for current tags when user first loads AND for the clicked tag when user clicks
    function addSelectedTag(tag) {
      const selectedTag = document.createElement("div");
      selectedTag.className = "selected-tag";
      selectedTag.id = tag.id; // we pass the tag.id to query the tag in POST
      const tagText = document.createElement("span");
      tagText.textContent = tag.name; // basically <span>anything inside here is the textContext</span> https://teamtreehouse.com/community/value-vs-textcontent
      const closeIcon = document.createElement("span");
      closeIcon.className = "close-icon";
      closeIcon.innerHTML = "✕"; // https://stackoverflow.com/questions/49197622/how-to-use-an-entity-with-textcontent

      selectedTag.appendChild(tagText);
      selectedTag.appendChild(closeIcon);
      selectedTagsContainer.appendChild(selectedTag);
      updateForm();


      // function to remove the tag when the x is pressed
      closeIcon.onclick = function () {
        selectedTagsContainer.removeChild(selectedTag);
        updateForm(); // update the deleted tag in the form
      };
    }


    // update the hidden form by reviewing the current state of the selectedTagsContainer
    // since this function is only used by createDropdown, is it better to nest the function?
    function updateForm() {
      const selectedTagsInput = document.getElementById("js-selected-tags");
      const selectedTags = [...selectedTagsContainer.getElementsByClassName("selected-tag")].map(x => x.id); // there are typically one or more tags which have been selected, so we turn the "selected-tag" elements in the selected tags container into an array. Then we map each element to its id
      selectedTagsInput.value = selectedTags.join(",");
      // console.log(selectedTagsInput.value);
    }


    // if user clicks outside the dropdown or the input, close the dropdown
    // alternative 1
    document.addEventListener("click", function (event) {
      if (
        !(
          suggestionsContainer.contains(event.target) ||
          input.contains(event.target)
        )
      ) {
        suggestionsContainer.hidden = true;
      } else suggestionsContainer.hidden = false;
    });

    // alternative 2
    // suggestionsContainer.addEventListener("focus", function () {
    //   suggestionsContainer.hidden = false;
    // });
    // suggestionsContainer.addEventListener("blur", function () {
    //   suggestionsContainer.hidden = true;
    // });
</script>
{% endblock %}
